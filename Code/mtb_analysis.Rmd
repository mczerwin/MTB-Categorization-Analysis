---
title: "MTB Categorization Analysis"
author: "Michael Czerwinski & Justin Schulberg"
date: "12/29/2021"
output:
  rmdformats::readthedown:
    self_contained: TRUE
    toc_depth: 4
    highlight: tango
    code_folding: hide
    lightbox: TRUE
    gallery: TRUE
    toc_float: # a float toc will stick to the sidebar when scrolling
      collapsed: false
      
---

```{r fig.align='center', fig.height=6, fig.width=6, message=FALSE, warning=FALSE, include=FALSE}
# Set our plot and code block specifications for the rest of the document.
knitr::opts_chunk$set(fig.width = 9,
                      fig.height = 6,
                      fig.align = "center",
                      # Set our code specifications for the rest of the document
                      echo = T,
                      warning = F,
                      message = F)

# Turn off scientific notation
options(scipen=999)

# install.packages("pacman")
# Use pacman to load packages. This'll check to see if a package is already installed; if not, it'll install it. If it is installed, it'll run the library() function.
library(pacman)
pacman::p_load(
  readxl, # Used for reading in Excel packages
  tidyverse, # Used for easy data manipulation
  here, # Used for navigating project structures
  kableExtra, # Used for RMarkdown formatting
  DataExplorer, # Used for easy EDA
  corrplot, # Used for correlation plotting
  pander # Pretty printing
  )


# Set our ggplot formats so we don't have to re-type the same code over-and-over again.
theme_set(theme_classic())
theme_update(plot.title = element_text(hjust = 0, color = "slateblue4", size = 20),
  plot.subtitle = element_text(hjust = 0, color = "slateblue2", size = 12),
  plot.caption = element_text(color = "dark gray", size = 10, face = "italic"),
  axis.title.x = element_text(size = 14),
  axis.title.y = element_text(size = 14),
  axis.text.y = element_text(size = 10),
  axis.text.x = element_text(size = 10))

```



# Introduction
For this project, our team will determine whether the specifications of mountain bikes (MTB) are enough to differentiate between the different types of mountain bike categories. 

Currently, full suspension mountain bikes come in multiple categories:

- **Cross Country (XC)** | Tend to be the most lightweight, nimble, and designed to put the rider in an efficient pedaling position 
- **Enduro** | Heavier frames, more travel and more downhill oriented geometry 
- **Trail** | The most common category of bikes, considered to be the halfway point between XC and Enduro
- **All Mountain** | A more niche category which some manufacturers claim to be more downhill focused than trail bikes, but not designed for downhill races like Enduro bikes are
- **Downcountry** | A relatively new category between XC and Trail. Similar to the All Mountain category, these bikes aren’t race specific like XC bikes tend to be, but are lighter and faster than trail bikes.

With all of the factors to consider when designing a bike, there are no clear boundaries between these categories. For example, one brand’s Downcountry bike could be what another brand considers a Trail bike. 

**The goal of our project is to determine how many, if any, discrete categories should exist for mountain bikes.** Since most specifications and geometric measurements have one direction when moving across the spectrum of bikes, it’s reasonable to believe that these measurements could be reduced to much fewer dimensions, and perhaps even one continuous principle component rather than discrete categories. Here is a diagram of some of the different types of geometric specifications on mountain bikes:

![Various Dimension Features of a Bike's Geometry](Images/Bike_Diagram.png)

Let's start by taking a look at the data.

```{r read_data}
# Read in sheet 2 of our data
mtb_data <- read_excel(here::here('Data/mtb_stats.xlsx'), 'Sheet1')
mtb_data <- mtb_data %>% 
  # Clean up the label column
  mutate(label = str_replace_all(str_to_lower(label), '[:punct:]', ''))

# Pull out the class labels
labels <- mtb_data %>% 
  select(label)


# Let's view the mtb_data output
# In any kable outputs, display NAs as blanks
opts <- options(knitr.kable.NA = "")

mtb_data %>% 
  head(25) %>%
  # Fix up the headers by replacing the underscores with spaces
  rename_all(funs(str_replace_all(., "_", " "))) %>% 
  # Make everything proper capitalization
  # rename_all(funs(str_to_title)) %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"),
                full_width = F,
                font_size = 12) %>%
  # Make the header row bold and black so it's easier to read
  row_spec(0, bold = T, color = "black") %>% 
  scroll_box(height = "400px", width = "100%")
```



# EDA

```{r demographics_explore}
DataExplorer::plot_bar(mtb_data, 
                       ggtheme = theme_classic(),
                       title = 'Distribution of Categorical Demographic Variables',
                       theme_config = theme(plot.title = element_text(hjust = 0, 
                                                                          color = "slateblue4", 
                                                                          size = 24),
                                                plot.subtitle = element_text(hjust = 0, color = "slateblue2", size = 10),
                                                plot.caption = element_text(color = "dark gray", size = 10, face = "italic"),
                                                axis.title.x = element_text(size = 14),
                                                axis.title.y = element_text(size = 14)),
                       maxcat = 10,
                       ncol = 2)

DataExplorer::plot_density(mtb_data,
                             ggtheme = theme_classic(),
                             title = 'Distribution of Continuous Demographic Variables',
                             geom_density_args = list(fill = 'slateblue'),
                             theme_config = theme(plot.title = element_text(hjust = 0, 
                                                                                color = "slateblue4", 
                                                                                size = 24),
                                                      plot.subtitle = element_text(hjust = 0, color = "slateblue2", size = 10),
                                                      plot.caption = element_text(color = "dark gray", size = 10, face = "italic"),
                                                      axis.title.x = element_text(size = 14),
                                                      axis.title.y = element_text(size = 14)),
                             ncol = 3)
```



## Average bikes by flip-chip setting
```{r setting}
# Split data based on setting vs. no setting
no_setting <- mtb_data %>% 
  filter(is.na(setting))
setting <- mtb_data %>% 
  filter(!is.na(setting))



setting <- cbind(setting$model, setting$label, select_if(setting, is.numeric))
setting$model <- setting$`setting$model`
setting <- setting %>% select(-`setting$model`)
setting$label <- setting$`setting$label`
setting <- setting %>% select(-`setting$label`)

mean_by_setting <- aggregate(x=select(setting, -c(model, label)),
                             by=list(setting$model, setting$label),
                             FUN=mean)
mean_by_setting$model <- mean_by_setting$Group.1
mean_by_setting$label <- mean_by_setting$Group.2
mean_by_setting <- mean_by_setting %>% select(-c(Group.1, Group.2))

no_setting <- cbind(no_setting$model, no_setting$label, select_if(no_setting, is.numeric))
no_setting$model <- no_setting$`no_setting$model`
no_setting <- no_setting %>% select(-`no_setting$model`)
no_setting$label <- no_setting$`no_setting$label`
no_setting <- no_setting %>% select(-`no_setting$label`)

new_mtb_data <- data.frame(rbind(mean_by_setting, no_setting))

rownames(new_mtb_data) <- new_mtb_data$model


```


# Variation Amongst Featureset
The first thing we'll do is look to see if any of the features in our dataset are better at explaining the variation amongst the different bikes than other features. That is, it's completely possible that two features are similar and don't have much variation in them, even across some of the different bike categories. To do so, we'll:

1. Look for highly correlated features and flag these for potential removal;  
2. Run Principal Component Analysis (PCA) to see if certain features are better at explaining the variation in our data better than others.

## 1. Correlation
First, let's take a look at our most highly correlated features. We'll use the `corrplot()` function to better order the highly correlated features by the angular order of their eigenvectors.

```{r correlation}
mtb_correlation <- mtb_data %>% 
  # Get rid of price for now
  select(-price) %>% 
  # Select our variables of interest
  select_if(is.numeric) %>% 
  # Remove rows with NAs in them
  # drop_na() %>% 
  # Build our correlation matrix, such that missing values are handled by casewise deletion
  cor(use = 'complete.obs') 

# Convert our results into a tibble for easier manipulation
mtb_correlation_df <- mtb_correlation %>% 
  as_tibble() %>% 
  mutate(variable = colnames(mtb_correlation)) %>% 
  relocate(variable, everything())

# Build our correlation plot, using the angular order of the eigenvectors
corrplot(mtb_correlation,
         diag = F,
         col = COL2('PRGn'),
         tl.col = 'slateblue4',
         type = 'lower',
         method = 'color',
         order = 'AOE',
         title = 'Mountain Bike Feature Correlation'
         )

```

Here we see some obvious correlations, for example:  
- `f_piston` (front brakes) is perfectly correlated with `r_piston` (rear brakes), which makes sense since mountain bikes tend to use the same types/spec of brakes for the front vs. rear tires.  
- `fork_travel` has a correlation above .95 with: `r mtb_correlation_df %>% select(variable, fork_travel) %>% filter((fork_travel > .95) | (fork_travel < -.95)) %>% select(variable) %>% as.character()`. This make sense; for example, `rear_travel` *should* be highly correlated with `fork_travel`. 

In all, here are the most highly correlated variables (i.e. variables which have a correlation above .95 or below -.95):

```{r high_correlation}
mtb_correlation_df %>% 
  pivot_longer(-variable, 
               names_to = 'correlated_variable', 
               values_to = 'correlation') %>% 
  filter(variable != correlated_variable) %>% 
  filter((correlation > .95) | (correlation < -.95)) %>% 
  pander()

```

For now, we'll opt to include everything. But later on, as we analyze the importance of different features, we'll look to remove some of the above variables first.

## 2. PCA
Next, we'll apply PCA to our dataset. In so doing, we'll have to center and scale our data given how different the ranges are for certain measurements. Let's take a look at our 5 principal components which explain the largest proportion of variance in the data:

```{r pca}

# Impute missing values with column mean (not really best practice, but good enough)
for (c in 1:ncol(new_mtb_data)){
  if (is.numeric(unlist(new_mtb_data[,c]))){
    # print(colnames(new_mtb_data)[c])
    new_mtb_data[is.na(new_mtb_data[,c]), c] <- mean(unlist(new_mtb_data[,c]), na.rm=TRUE)  
  }
}

# TODO get average bikes by setting  to work above
mtb_no_null <- new_mtb_data %>% 
                select(-price) %>%
                select_if(is.numeric) %>% 
                bind_cols(label = new_mtb_data$label) %>%
                drop_na()


# head(mtb_no_null)


mtb_pca <- prcomp(mtb_no_null %>% select(-label),
                  center = TRUE,
                  scale. = TRUE)

# Put our summary results into a dataframe
mtb_pca_df <- tibble(variable = c('Standard Deviation', 'Proportion of Variance', 'Cumulative Proportion')) %>% 
  cbind(summary(mtb_pca)$importance)


# head(mtb_pca_df)

mtb_pca_df %>% 
  # Only display the first 6 columns
  select(c(variable:PC5)) %>% 
  pander()


```

We can see that, actually, starting at our $5^{\text{rd}}$ principal component, nearly `r 100*round(mtb_pca_df %>% filter(variable == 'Cumulative Proportion') %>% select(PC5) %>% as.numeric(), 3)`% of the data's variation is properly explained. Let's take a look at our top 2 principal components:

```{r pca_viz}
p_load(devtools,
       ggbiplot)

ggbiplot(mtb_pca,
              obs.scale = 1,
              var.scale = 1,
              groups = mtb_no_null$label,
              ellipse = TRUE,
              circle = FALSE,
              ellipse.prob = .5) + 
  theme(legend.direction = 'horizontal',
               legend.position = 'top')

# jpeg('../Images/pca.jpg')

```

Here we can see that our top 2 principal components, which explain roughly `r 100*round(mtb_pca_df %>% filter(variable == 'Cumulative Proportion') %>% select(PC2) %>% as.numeric(), 3)`% of the variation in our data, are already pretty good representations for describing the different components in our dataset. Even so, the groupings are distinctly plotted on the 2-D graph.

# Rowdiness scale


# Clustering

## K-Means
```{r}
# How many clusters are necessary? 4
<<<<<<< HEAD

mtb_numeric <- mtb_no_null %>% select(-label)
mtb_standard_scaled <- scale(mtb_numeric)
=======
mtb_numeric <- mtb_no_null %>% 
  select(-label)
>>>>>>> 3b90766b6aa84d2301b110ad3d48bc86af28ae3b

clusters <- 1:10
dists <- c()
for (c in 1:10){
  km <- kmeans(mtb_scaled_twice, centers=c, iter.max=1000)
  dists <- c(dists, km$tot.withinss)
}

# jpeg('../Images/Kmeans.jpg')
# plot(clusters, dists, type='l', xlab='Clusters', ylab='Total Sum of Squared Euclidean Distances')

# Plot our results
tibble(clusters = clusters,
       dists = dists) %>% 
  ggplot(aes(x = clusters, y = dists)) + 
  geom_point(size = 3, alpha = .9, color = 'slateblue') +
  geom_line(size = 2, alpha = 1, color = 'slateblue1') + 
  labs(title = "K-Means Clustering of MTB Data",
       subtitle = 'Method uses `tot.withinss` parameter to measure distances.',
       x = 'Clusters',
       y = 'Total Sum of Squared Euclidean Distances')

```

```{r}
# Let's see where these clusters would end up on the 2D PCA plot


mtb_pca_scaled <- prcomp(mtb_standard_scaled,
                  center = F,
                  scale. = F)

pca_2_scaled <- as.matrix(mtb_standard_scaled) %*% as.matrix(mtb_pca_scaled$rotation[,1:2])

pca_km_scaled <- kmeans(pca_2_scaled, centers=3, iter.max=1000)

#Something's not working here, definitely hitting a local min or something
colorgroups <- function(g){
  if (g == 'tr' || g == 'Trail'){
    return('blue')
  }
  else if (g == 'xc' || g == 'Cross Country'){
    return('pink')
  }
  else if (g == 'dc' || g == 'Downcountry'){
    return('darkgoldenrod3')
  }
  else if (g == 'am' || g == 'All Mountain'){
    return('red')
  }
  else if (g == 'en' || g == 'Enduro'){
    return('green')
  }
}
catNames <- c('Cross Country', 'Downcountry', 'Trail', 'All Mountain', 'Enduro')
cols <- unlist(lapply(new_mtb_data$label, colorgroups))
<<<<<<< HEAD

jpeg('../Images/PCA_clusters.jpg')
=======
unlist(lapply(catNames, colorgroups))
# jpeg('../Images/PCA_clusters.jpg')
>>>>>>> 3b90766b6aa84d2301b110ad3d48bc86af28ae3b
plot(pca_2_scaled, col=cols)
points(pca_km_scaled$centers, col = 'slateblue4', pch = 'x', cex = 1.5)
# text(pca_2_scaled[,1], pca_2_scaled[,2], rownames(pca_2_scaled))
legend("bottomleft", legend= c(catNames, 'Cluster Center'), col=c(unlist(lapply(catNames, colorgroups)), 'black'), pch=c(rep('o', 5), 'X'))

#TODO let's look at this bottom cluster - both Niner bikes
#Niner has low reach numbers on its bikes - could be because we used the Medium for these!
#Based on PCA mapping, the blur tr, expic, Exie, Ripley, and Element all have less chainstay length, and less pistons?? wow, should we exclude piston count?? with more 2 piston bikes getting added, it evens out the average, so these aren't showing up as much anymore


```


## Gaussian Mixture Model (GMM)
In this section, we'll take a more probabilistic model to our clustering. That is, we'll use a Guassian Mixture Model (GMM) to build out normally distributed subgroupings within our mountain bike dataset, where the densities of each of the subgroupings represents a probability that a bike belongs to that subgrouping. Unlike K-Means, which is a more centroid-based clustering method, GMM is more of a distribution-based clustering method.

```{r gmm}
p_load(ClusterR)

# Build our GMM model
mtb_gmm <- GMM(mtb_standard_scaled,
               dist_mode = 'eucl_dist', # Distance metric to use during seeding of initial means clustering
               seed_mode = 'random_subset', # How initial means are seeded prior to EM alg
               km_iter = 10, # Num of iterations of K-Means alg
               em_iter = 10, # Num of iterations of EM alg
               verbose = T
               )

mtb_gmm_pred <- predict(mtb_gmm, mtb_standard_scaled)

opt_gmm <- Optimal_Clusters_GMM(mtb_standard_scaled, 
                               max_clusters = 20, 
                               criterion = "BIC", 
                               dist_mode = "eucl_dist", 
                               seed_mode = "random_subset",
                               km_iter = 10, 
                               em_iter = 10, 
                               var_floor = 1e-10, 
                               plot_data = T)


```

Use the `mclust` package in R, which utilizes Bayesian Information Criterion (BIC) to optimize the number of clusters.
```{r gmm2}
p_load(mclust)

mtb_gmm2 <- Mclust(mtb_standard_scaled)

#or specify number of clusters
# mb3 = Mclust(iris[,-5], 3)

# optimal selected model
mtb_gmm2$modelName

# optimal number of cluster
mtb_gmm2$G

# probality for an observation to be in a given cluster
head(mtb_gmm2)

# get probabilities, means, variances
summary(mtb_gmm2, parameters = TRUE)

plot(mtb_gmm2, 'classification')

```



## Multi-class SVM




# Conclusions/Findings

